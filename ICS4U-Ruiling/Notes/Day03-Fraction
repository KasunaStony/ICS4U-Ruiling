
How to store -4.75 in 8 bit memory:

_ _ _ _ _ _ _ _

第一位是符号位,正数0,负数1

第二到四位是指数位

后四位是小数位

0. 确定符号位:

1 _ _ _ _ _ _ _

1. 把整数位转化为二进制:

4 ---> 100

2. 把小数转化为二进制:
方法: 每次乘2,结果有整数1就写下1,没有就写0

_._ _ _ _
0.75 --->
0.75 * 2 ---> 1.5 [把1留下]
_.1 _ _ _
1.5 - 1 = 0.5

0.5 * 2 = 1.0
_.1 1 _ _
1.0 - 1 = 0.0

这样就完成了

3. 把整数和小数结合在一起:

-4.75 ---> -100.11
科学计数法:
-100.11 = -1.0011 * 2^2

指数为2

4. 确定指数位:

资料: 为了节省内存,指数位上没有符号位.但是有负数指数,所以一律加一个BIAS,把所以指数变成正数
BIAS的公式: 2^(k-1) - 1
k值（即指数占几个bit）:
8位: 3
16位: 5
32位: 8
64位: 11

在这个例子中,指数为2,BIAS为 2^(3-1) - 1 = 3 2+3=5
5是指数位
5 ---> 101

5. 答案:
1 101 0011
后四位就是科学计数法后的原数的小数部分（因为在二进制中,科学计数法的整数位总是1,所以不用储存 -- 二进制只有0和1,科学计数法的整数位不可能是0）

使用16进制来储存小数:

4632 0010

(十六进制转二进制的时候一个数位转二进制的4个数位)

0100 0110 0011 0010 0000 0000 0001 0000

32位的小数（单精度,float）

第一位符号位: 0, 说明是正数

后面8位指数位: 10001100 ---> 140

减去BIAS
BIAS = 2^(8-1) - 1 = 127

140 - 127 = 13

指数是13

后面23位是小数位: 011 0010 0000 0000 0001 0000

科学计数法: 1.0110 0100 0000 0000 0010 000 * 2^13
展开: 1011 0010 0000 00.0000 0100 00
是正数

十进制: 11392 + 1/64 = 11392.015625

(我也不知道对不对...反正就是这么做的)

