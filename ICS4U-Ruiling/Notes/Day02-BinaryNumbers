
Signed: the range of the data has both positive (including 0) and negative values
Unsigned: the range of the data only have positive values (including 0)

3 bits:
0 0 0 [0]
0 0 1 [1]
0 1 0 [2]
0 1 1 [3]
1 0 0 [4]
1 0 1 [5]
1 1 0 [6]
1 1 1 [7]
This is unsigned
(total 8 ways)

Signed:
1 0 0 [-4]
1 0 1 [-3]
1 1 0 [-2]
1 1 1 [-1]
0 0 0 [0]
0 0 1 [1]
0 1 0 [2]
0 1 1 [3]
This is signed

怎么得到二进制的-1:

    (1) 0 0 0
  -  `  0 0 1
----------------- (使用正常计算中的借位)
        1 1 1

其他的可以继续推算

转化负数二进制的简便方法:
将原数转化为正数二进制,每一位数1变0,0变1,完成后+1即是负数二进制

如:
将9转化为8位二进制:

正数二进制:
0000 1001
翻转:
1111 0110
+1:
1111 0111

p.s.:
看一个有符号的二进制数的正负:
开头是0: 正数
开头是1: 负数
(第一位为符号位)

关于小数的精度问题:

参考知乎回答
https://www.zhihu.com/question/42024389

0.2345 (dec) 2是2*1/10,3是3*1/100,4是4*1/1000...以此类推
二进制同样
0.1101 (bin) 第一个1是1*1/2,第二个1是1*1/4,第三个0是0*0/8,第四个1是1*1/16...以此类推
那么来转化0.525:

0.5 = 1/2
0.1...
0.525 - 0.5 剩下 0.025
1/4 太大,1/8太大,1/16太大...1/64 = 0.015625
那么0.100001...
这样算下去,因为浮点数double只有64位,最后总会约减,导致不精确

但有些浮点数可以精确储存:

如:

double x = 1.5;
double b = 0.5 + 0.5 + 0.5;
System.out.println(x == b);

结果是true,因为0.5在二进制中刚好是0.1,所以没有精度问题
(但是比较double还是别用 == 的好...)
